"""
Enhanced Intent Detector - Multi-stage pattern matching with context awareness
"""

import logging
import re
import asyncio
from typing import Dict, Any, Optional, List, Tuple
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class IntentType(Enum):
    """Intent t√ºrleri"""
    GREETING = "greeting"
    THANKS = "thanks"
    FAREWELL = "farewell"
    ACKNOWLEDGMENT = "acknowledgment"
    NEGATIVE = "negative"
    CLARIFICATION_NEEDED = "clarification_needed"
    BUSINESS_INFO = "business_info"
    PRODUCT_INQUIRY = "product_inquiry"
    NEEDS_LLM = "needs_llm"
    HUMAN_TRANSFER = "human_transfer"

class ConfidenceLevel(Enum):
    """G√ºven seviyeleri"""
    VERY_HIGH = 0.95
    HIGH = 0.85
    MEDIUM = 0.70
    LOW = 0.55
    VERY_LOW = 0.40

@dataclass
class Entity:
    """Extracted entity"""
    type: str
    value: str
    confidence: float
    start_pos: int
    end_pos: int

@dataclass
class IntentResult:
    """Intent detection sonucu"""
    intent: IntentType
    confidence: float
    entities: List[Entity]
    context: Dict[str, Any]
    requires_llm: bool
    function_call: Optional[Dict[str, Any]]
    response: Optional[str]
    method: str
    explanation: str

class EnhancedIntentDetector:
    """Geli≈ümi≈ü intent detection sistemi"""
    
    def __init__(self):
        self.context_memory = {}  # session_id -> context
        
        # EXACT PATTERNS - En y√ºksek √∂ncelik
        self.exact_patterns = {
            # Selamlama
            "merhaba": (IntentType.GREETING, "Merhaba! Butik Cem√ºnay'a ho≈ü geldiniz. Size nasƒ±l yardƒ±mcƒ± olabilirim?"),
            "selam": (IntentType.GREETING, "Merhaba! Butik Cem√ºnay'a ho≈ü geldiniz. Size nasƒ±l yardƒ±mcƒ± olabilirim?"),
            "hello": (IntentType.GREETING, "Merhaba! Butik Cem√ºnay'a ho≈ü geldiniz. Size nasƒ±l yardƒ±mcƒ± olabilirim?"),
            "hi": (IntentType.GREETING, "Merhaba! Butik Cem√ºnay'a ho≈ü geldiniz. Size nasƒ±l yardƒ±mcƒ± olabilirim?"),
            
            # Te≈üekk√ºr
            "te≈üekk√ºrler": (IntentType.THANKS, "Rica ederim! Ba≈üka sorunuz var mƒ±?"),
            "te≈üekk√ºr": (IntentType.THANKS, "Rica ederim! Ba≈üka sorunuz var mƒ±?"),
            "saƒüol": (IntentType.THANKS, "Rica ederim! Ba≈üka sorunuz var mƒ±?"),
            "thanks": (IntentType.THANKS, "Rica ederim! Ba≈üka sorunuz var mƒ±?"),
            
            # Vedala≈üma
            "ho≈ü√ßa kal": (IntentType.FAREWELL, "Ho≈ü√ßa kalƒ±n! Tekrar bekleriz. üòä"),
            "g√ºle g√ºle": (IntentType.FAREWELL, "Ho≈ü√ßa kalƒ±n! Tekrar bekleriz. üòä"),
            "g√∂r√º≈ü√ºr√ºz": (IntentType.FAREWELL, "Ho≈ü√ßa kalƒ±n! Tekrar bekleriz. üòä"),
            "bye": (IntentType.FAREWELL, "Ho≈ü√ßa kalƒ±n! Tekrar bekleriz. üòä"),
            
            # Onay/Anlama
            "tamam": (IntentType.ACKNOWLEDGMENT, "Ba≈üka bir sorunuz var mƒ±?"),
            "ok": (IntentType.ACKNOWLEDGMENT, "Ba≈üka bir sorunuz var mƒ±?"),
            "peki": (IntentType.ACKNOWLEDGMENT, "Ba≈üka bir sorunuz var mƒ±?"),
            "anladƒ±m": (IntentType.ACKNOWLEDGMENT, "Ba≈üka bir sorunuz var mƒ±?"),
            "evet": (IntentType.ACKNOWLEDGMENT, "Ba≈üka bir sorunuz var mƒ±?"),
            
            # Red/Olumsuz
            "yok": (IntentType.NEGATIVE, "Te≈üekk√ºr ederiz! ƒ∞yi g√ºnler dileriz. üòä"),
            "hayƒ±r": (IntentType.NEGATIVE, "Ba≈üka bir konuda yardƒ±mcƒ± olabilirim."),
            "istemiyorum": (IntentType.NEGATIVE, "Ba≈üka bir konuda yardƒ±mcƒ± olabilirim."),
        }
        
        # BUSINESS INFO PATTERNS
        self.business_patterns = {
            "telefon": {
                "keywords": ["telefon", "phone", "ileti≈üim", "numar", "ara", "tel"],
                "function_call": {"name": "getGeneralInfo", "args": {"info_type": "telefon"}}
            },
            "iade": {
                "keywords": ["iade", "return", "geri", "deƒüi≈üim", "deƒüi≈ütir", "iade var", 
                           "iade var mƒ±", "iade yapabilir", "iade edebilir", "geri verebilir",
                           "iade ≈üart", "iade policy", "iade nasƒ±l", "nasƒ±l iade", 
                           "iade s√ºresi", "ka√ß g√ºn iade"],
                "function_call": {"name": "getGeneralInfo", "args": {"info_type": "iade"}}
            },
            "kargo": {
                "keywords": ["kargo", "teslimat", "shipping", "cargo"],
                "function_call": {"name": "getGeneralInfo", "args": {"info_type": "kargo"}}
            },
            "site": {
                "keywords": ["site", "web", "website"],
                "function_call": {"name": "getGeneralInfo", "args": {"info_type": "site"}}
            }
        }
        
        # PRODUCT QUERY PATTERNS
        self.product_query_patterns = [
            "fiyat", "ka√ß para", "ne kadar", "price", "√ºcret",
            "stok", "var mƒ±", "mevcut", "stock", "kaldƒ±",
            "renk", "color", "renkler", "hangi renk",
            "beden", "size", "bedenleri", "hangi beden",
            "detay", "bilgi", "√∂zellik", "nasƒ±l", "info"
        ]
        
        # PRODUCT NAME PATTERNS
        self.product_names = [
            "gecelik", "geceliƒüi", "geceliƒüin", "geceliƒüe",
            "pijama", "pijamayƒ±", "pijamanƒ±n", "pijamaya", 
            "elbise", "elbiseyi", "elbisenin", "elbiseye",
            "sabahlƒ±k", "sabahlƒ±ƒüƒ±", "sabahlƒ±ƒüƒ±n", "sabahlƒ±ƒüa",
            "takƒ±m", "takƒ±mƒ±", "takƒ±mƒ±n", "takƒ±ma",
            "hamile", "lohusa", "afrika", "dantelli", "siyah", "beyaz",
            "kol", "omuz", "yaka", "d√ºƒümeli", "dekolteli", "askƒ±lƒ±"
        ]
        
        # NONSENSE PATTERNS - Anlamsƒ±z sorgular
        self.nonsense_patterns = [
            "fiyat sorcaktƒ±m", "fiyat sroacaktƒ±m", "soracaktƒ±m", "diyecektim",
            "annen", "baban", "karde≈üin", "ablan", "aƒüabeyin",
            "asdfgh", "qwerty", "123456", "test", "deneme"
        ]
        
        # CONTEXT PATTERNS - Takip sorularƒ±
        self.context_patterns = [
            "bunun", "onun", "≈üunun", "bu √ºr√ºn√ºn", "o √ºr√ºn√ºn",
            "daha", "ba≈üka", "diƒüer", "farklƒ±"
        ]
    
    async def detect_intent(self, message: str, session_id: str = None, 
                          context: Dict[str, Any] = None) -> IntentResult:
        """Ana intent detection fonksiyonu"""
        
        if not message or not message.strip():
            return IntentResult(
                intent=IntentType.CLARIFICATION_NEEDED,
                confidence=ConfidenceLevel.VERY_HIGH.value,
                entities=[],
                context={},
                requires_llm=False,
                function_call=None,
                response="Merhaba! Size nasƒ±l yardƒ±mcƒ± olabilirim?",
                method="empty_message",
                explanation="Empty or whitespace-only message"
            )
        
        message_clean = message.lower().strip()
        
        # 1. NONSENSE DETECTION - En √∂nce kontrol et
        nonsense_result = self._detect_nonsense(message_clean)
        if nonsense_result:
            return nonsense_result
        
        # 2. EXACT PATTERN MATCHING - Kesin e≈üle≈ümeler
        exact_result = self._detect_exact_patterns(message_clean)
        if exact_result:
            return exact_result
        
        # 3. BUSINESS INFO DETECTION
        business_result = self._detect_business_info(message_clean)
        if business_result:
            return business_result
        
        # 4. PRODUCT QUERY DETECTION - En karma≈üƒ±k kƒ±sƒ±m
        product_result = await self._detect_product_query(message_clean, session_id, context)
        if product_result:
            return product_result
        
        # 5. CONTEXT-AWARE DETECTION - Takip sorularƒ±
        if session_id:
            context_result = self._detect_contextual_query(message_clean, session_id)
            if context_result:
                return context_result
        
        # 6. SHORT MESSAGE HANDLING
        short_result = self._handle_short_messages(message_clean)
        if short_result:
            return short_result
        
        # 7. COMPLEX QUERY - LLM'e g√∂nder
        return IntentResult(
            intent=IntentType.NEEDS_LLM,
            confidence=ConfidenceLevel.MEDIUM.value,
            entities=self._extract_basic_entities(message_clean),
            context=context or {},
            requires_llm=True,
            function_call=None,
            response=None,
            method="needs_llm",
            explanation="Complex query requiring LLM analysis"
        )
    
    def _detect_nonsense(self, message: str) -> Optional[IntentResult]:
        """Anlamsƒ±z sorgularƒ± tespit et"""
        for nonsense in self.nonsense_patterns:
            if nonsense in message:
                return IntentResult(
                    intent=IntentType.CLARIFICATION_NEEDED,
                    confidence=ConfidenceLevel.VERY_HIGH.value,
                    entities=[],
                    context={},
                    requires_llm=False,
                    function_call=None,
                    response="Anlayamadƒ±m. √úr√ºn, fiyat, iade veya ileti≈üim hakkƒ±nda sorabilirsiniz.",
                    method="nonsense_detection",
                    explanation=f"Detected nonsense pattern: {nonsense}"
                )
        return None
    
    def _detect_exact_patterns(self, message: str) -> Optional[IntentResult]:
        """Kesin pattern e≈üle≈ümelerini tespit et"""
        if message in self.exact_patterns:
            intent_type, response = self.exact_patterns[message]
            return IntentResult(
                intent=intent_type,
                confidence=ConfidenceLevel.VERY_HIGH.value,
                entities=[],
                context={},
                requires_llm=False,
                function_call=None,
                response=response,
                method="exact_pattern",
                explanation=f"Exact pattern match: {message}"
            )
        return None
    
    def _detect_business_info(self, message: str) -> Optional[IntentResult]:
        """ƒ∞≈ületme bilgi sorgularƒ±nƒ± tespit et"""
        for info_type, config in self.business_patterns.items():
            # Keyword matching
            if any(keyword in message for keyword in config["keywords"]):
                # √úr√ºn adƒ± da varsa √ºr√ºn sorgusu olabilir - kontrol et
                has_product = any(product in message for product in self.product_names)
                if not has_product:
                    return IntentResult(
                        intent=IntentType.BUSINESS_INFO,
                        confidence=ConfidenceLevel.HIGH.value,
                        entities=[Entity("info_type", info_type, 0.9, 0, len(message))],
                        context={"info_type": info_type},
                        requires_llm=False,
                        function_call=config["function_call"],
                        response=None,
                        method="business_pattern",
                        explanation=f"Business info query detected: {info_type}"
                    )
        return None
    
    async def _detect_product_query(self, message: str, session_id: str = None, 
                                  context: Dict[str, Any] = None) -> Optional[IntentResult]:
        """√úr√ºn sorgularƒ±nƒ± tespit et - En karma≈üƒ±k kƒ±sƒ±m"""
        
        has_product_query = any(pattern in message for pattern in self.product_query_patterns)
        has_product_name = any(product in message for product in self.product_names)
        
        # Extract entities
        entities = self._extract_product_entities(message)
        
        # Sadece √ºr√ºn sorgu kelimesi varsa ve √ºr√ºn adƒ± yoksa belirsiz
        if has_product_query and not has_product_name:
            words = message.split()
            if len(words) <= 1:
                query_word = words[0] if words else "bilgi"
                return IntentResult(
                    intent=IntentType.CLARIFICATION_NEEDED,
                    confidence=ConfidenceLevel.HIGH.value,
                    entities=entities,
                    context={"incomplete_query": True, "query_type": query_word},
                    requires_llm=False,
                    function_call=None,
                    response=f"Hangi √ºr√ºn√ºn {query_word} bilgisini √∂ƒürenmek istiyorsunuz?",
                    method="incomplete_query",
                    explanation=f"Incomplete product query: {query_word}"
                )
        
        # Hem √ºr√ºn sorgusu hem √ºr√ºn adƒ± varsa √ºr√ºn sorgusu
        if has_product_query and has_product_name:
            return IntentResult(
                intent=IntentType.PRODUCT_INQUIRY,
                confidence=ConfidenceLevel.HIGH.value,
                entities=entities,
                context={"has_product_query": True, "has_product_name": True},
                requires_llm=False,
                function_call=None,
                response=None,
                method="product_pattern",
                explanation="Product query with both query type and product name"
            )
        
        # Sadece √ºr√ºn adƒ± varsa da √ºr√ºn sorgusu
        if has_product_name:
            return IntentResult(
                intent=IntentType.PRODUCT_INQUIRY,
                confidence=ConfidenceLevel.MEDIUM.value,
                entities=entities,
                context={"has_product_name": True},
                requires_llm=False,
                function_call=None,
                response=None,
                method="product_name_only",
                explanation="Product query with product name only"
            )
        
        return None
    
    def _detect_contextual_query(self, message: str, session_id: str) -> Optional[IntentResult]:
        """Context-aware sorgu tespiti"""
        has_context_pattern = any(pattern in message for pattern in self.context_patterns)
        has_product_query = any(pattern in message for pattern in self.product_query_patterns)
        
        if has_context_pattern or has_product_query:
            # Session context'ini kontrol et
            session_context = self.context_memory.get(session_id, {})
            last_product = session_context.get("last_product")
            
            if last_product:
                return IntentResult(
                    intent=IntentType.PRODUCT_INQUIRY,
                    confidence=ConfidenceLevel.MEDIUM.value,
                    entities=[Entity("product", last_product, 0.8, 0, len(message))],
                    context={"contextual_query": True, "referenced_product": last_product},
                    requires_llm=False,
                    function_call=None,
                    response=None,
                    method="contextual_query",
                    explanation=f"Contextual query referencing: {last_product}"
                )
        
        return None
    
    def _handle_short_messages(self, message: str) -> Optional[IntentResult]:
        """Kƒ±sa mesajlarƒ± i≈üle"""
        words = message.split()
        if len(words) <= 2:
            # Tek kelime √ºr√ºn sorgularƒ±
            if len(words) == 1 and words[0] in self.product_query_patterns:
                return IntentResult(
                    intent=IntentType.CLARIFICATION_NEEDED,
                    confidence=ConfidenceLevel.HIGH.value,
                    entities=[Entity("query_type", words[0], 0.9, 0, len(words[0]))],
                    context={"incomplete_query": True, "query_type": words[0]},
                    requires_llm=False,
                    function_call=None,
                    response=f"Hangi √ºr√ºn√ºn {words[0]} bilgisini √∂ƒürenmek istiyorsunuz?",
                    method="incomplete_query",
                    explanation=f"Single word query: {words[0]}"
                )
            
            # Diƒüer kƒ±sa mesajlar
            return IntentResult(
                intent=IntentType.CLARIFICATION_NEEDED,
                confidence=ConfidenceLevel.MEDIUM.value,
                entities=[],
                context={"short_message": True},
                requires_llm=False,
                function_call=None,
                response="Tam olarak ne hakkƒ±nda bilgi almak istiyorsunuz? √úr√ºn, fiyat, iade veya ileti≈üim konularƒ±nda yardƒ±mcƒ± olabilirim.",
                method="short_message",
                explanation=f"Short message with {len(words)} words"
            )
        
        return None
    
    def _extract_basic_entities(self, message: str) -> List[Entity]:
        """Temel entity extraction"""
        entities = []
        
        # Product names
        for product in self.product_names:
            if product in message:
                start_pos = message.find(product)
                entities.append(Entity(
                    type="product",
                    value=product,
                    confidence=0.8,
                    start_pos=start_pos,
                    end_pos=start_pos + len(product)
                ))
        
        # Query types
        for query_type in self.product_query_patterns:
            if query_type in message:
                start_pos = message.find(query_type)
                entities.append(Entity(
                    type="query_type",
                    value=query_type,
                    confidence=0.9,
                    start_pos=start_pos,
                    end_pos=start_pos + len(query_type)
                ))
        
        return entities
    
    def _extract_product_entities(self, message: str) -> List[Entity]:
        """√úr√ºn-specific entity extraction"""
        entities = []
        
        # Product names (garment types)
        garment_types = ["gecelik", "geceliƒüi", "pijama", "pijamayƒ±", "elbise", "elbiseyi", 
                        "sabahlƒ±k", "sabahlƒ±ƒüƒ±", "takƒ±m", "takƒ±mƒ±"]
        
        for garment in garment_types:
            if garment in message:
                start_pos = message.find(garment)
                entities.append(Entity(
                    type="product",
                    value=garment,
                    confidence=0.9,
                    start_pos=start_pos,
                    end_pos=start_pos + len(garment)
                ))
        
        # Target groups
        target_groups = ["hamile", "lohusa", "b√ºy√ºk beden"]
        
        for target in target_groups:
            if target in message:
                start_pos = message.find(target)
                entities.append(Entity(
                    type="target_group",
                    value=target,
                    confidence=0.8,
                    start_pos=start_pos,
                    end_pos=start_pos + len(target)
                ))
        
        # Colors
        colors = ["siyah", "beyaz", "kƒ±rmƒ±zƒ±", "mavi", "ye≈üil", "sarƒ±", "pembe", "mor", 
                 "lacivert", "bordo", "bej", "ekru", "gri", "krem", "turuncu"]
        
        for color in colors:
            if color in message:
                start_pos = message.find(color)
                entities.append(Entity(
                    type="color",
                    value=color,
                    confidence=0.9,
                    start_pos=start_pos,
                    end_pos=start_pos + len(color)
                ))
        
        # Product features
        features = ["dantelli", "d√ºƒümeli", "dekolteli", "askƒ±lƒ±", "kol", "omuz", "yaka"]
        
        for feature in features:
            if feature in message:
                start_pos = message.find(feature)
                entities.append(Entity(
                    type="feature",
                    value=feature,
                    confidence=0.8,
                    start_pos=start_pos,
                    end_pos=start_pos + len(feature)
                ))
        
        # Query types
        for query_type in self.product_query_patterns:
            if query_type in message:
                start_pos = message.find(query_type)
                entities.append(Entity(
                    type="query_type",
                    value=query_type,
                    confidence=0.9,
                    start_pos=start_pos,
                    end_pos=start_pos + len(query_type)
                ))
        
        return entities
    
    def update_context(self, session_id: str, context_data: Dict[str, Any]):
        """Session context'ini g√ºncelle"""
        if session_id not in self.context_memory:
            self.context_memory[session_id] = {}
        
        self.context_memory[session_id].update(context_data)
    
    def get_context(self, session_id: str) -> Dict[str, Any]:
        """Session context'ini al"""
        return self.context_memory.get(session_id, {})
    
    def clear_context(self, session_id: str):
        """Session context'ini temizle"""
        if session_id in self.context_memory:
            del self.context_memory[session_id]
    
    def calculate_confidence(self, matches: List[Tuple[str, float]]) -> float:
        """Confidence hesaplama"""
        if not matches:
            return 0.0
        
        # Weighted average of matches
        total_weight = sum(weight for _, weight in matches)
        if total_weight == 0:
            return 0.0
        
        weighted_sum = sum(score * weight for score, weight in matches)
        return min(weighted_sum / total_weight, 1.0)

# Global instance
enhanced_intent_detector = EnhancedIntentDetector()